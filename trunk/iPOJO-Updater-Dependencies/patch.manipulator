Index: src/main/java/org/apache/felix/ipojo/manipulation/MethodCreator.java
===================================================================
--- src/main/java/org/apache/felix/ipojo/manipulation/MethodCreator.java	(révision 1026267)
+++ src/main/java/org/apache/felix/ipojo/manipulation/MethodCreator.java	(copie de travail)
@@ -50,7 +50,8 @@
     /**
      * All POJO method will be renamed by using this prefix.
      */
-    private static final String PREFIX = "__";
+    // -- PATCH - Thomas Calmant - make it visible --
+    public static final String PREFIX = "__";
 
     /**
      * POJO class.
Index: src/main/java/org/apache/felix/ipojo/manipulator/Pojoization.java
===================================================================
--- src/main/java/org/apache/felix/ipojo/manipulator/Pojoization.java	(révision 1026267)
+++ src/main/java/org/apache/felix/ipojo/manipulator/Pojoization.java	(copie de travail)
@@ -45,6 +45,7 @@
 
 import org.apache.felix.ipojo.manipulation.InnerClassManipulator;
 import org.apache.felix.ipojo.manipulation.Manipulator;
+import org.apache.felix.ipojo.manipulation.MethodCreator;
 import org.apache.felix.ipojo.manipulation.annotations.MetadataCollector;
 import org.apache.felix.ipojo.metadata.Attribute;
 import org.apache.felix.ipojo.metadata.Element;
@@ -127,11 +128,17 @@
      */
     private File m_manifest;
 
+    // -- BEGIN PATCH -- isandlaTech (T.C.) - Manifest attribute filters -- //
+    /** Manifest attribute filter, with default iPOJO filters */
+    private List/*IManifestAttributeFilter*/ m_manifestAttributeFilters = new ArrayList/*IManifestAttributeFilter*/();
+    // -- END PATCH -- isandlaTech (T.C.) - Manifest attribute filters -- //
+
     /**
      * Add an error in the error list.
      * @param mes : error message.
      */
-    private void error(String mes) {
+    // -- PATCH -- isandlaTech (T.C.) - Let it be overriden by children -- //
+    protected void error(String mes) {
         System.err.println(mes);
         m_errors.add(mes);
     }
@@ -439,9 +446,8 @@
             // The class name is already a path
             File classFile = new File(m_dir, classname);
             try {
-                OutputStream os = new FileOutputStream(classFile);
-                os.write(clazz);
-                os.close();
+                // -- PATCH - isandlaTech (T.C.) - Let the write process be overriden -- //
+                setBytecode(classFile, clazz);
             } catch (IOException e) {
                 error("Cannot manipulate the file : the output file " +  classname + " is not found");
                 return;
@@ -449,20 +455,9 @@
         }
 
         // Write manifest
-        if (m_manifest == null) {
-            m_manifest = new File(m_dir, "META-INF/MANIFEST.MF");
-            if (! m_manifest.exists()) {
-                error("Cannot find the manifest file : " + m_manifest.getAbsolutePath());
-                return;
-            }
-        } else {
-            if (! m_manifest.exists()) {
-                error("Cannot find the manifest file : " + m_manifest.getAbsolutePath());
-                return;
-            }
-        }
         try {
-            mf.write(new FileOutputStream(m_manifest));
+            // -- PATCH - isandlaTech (T.C.) - Let the write process be overriden -- //
+            writeManifest(mf);
         } catch (IOException e) {
             error("Cannot write the manifest file : " + e.getMessage());
         }
@@ -488,7 +483,14 @@
 
                     // This method adds the class to the component list
                     // if that bytecode is annotated with @Component.
-                    computeAnnotations(in);
+
+                    // -- BEGIN PATCH - isandlaTech (T.C.) - Do not analyse empty files -- //
+                    if(in != null || in.length > 0) {
+                        computeAnnotations(in);
+                    } else {
+                        error("Empty file : " + curName);
+                    }
+                    // -- END PATCH - isandlaTech (T.C.) -- //
                 } catch (IOException e) {
                     error("Cannot read the class : " + curName);
                     return;
@@ -538,7 +540,8 @@
      * @return a byte array
      * @throws IOException if the classname cannot be read
      */
-    private byte[] getBytecode(final String classname) throws IOException {
+    // -- PATCH - isandlaTech (T.C.) - Let it be overriden by a child class -- //
+    protected byte[] getBytecode(final String classname) throws IOException {
 
         InputStream currIn = null;
         byte[] in = new byte[0];
@@ -622,7 +625,8 @@
      * @param dir the directory to analyze
      * @param classes discovered classes
      */
-    private void searchClassFiles(File dir, List classes) {
+    // -- PATCH - isandlaTech (T.C.) - Let it be overriden -- //
+    protected void searchClassFiles(File dir, List classes) {
         File[] files = dir.listFiles();
         for (int i = 0; i < files.length; i++) {
             if (files[i].isDirectory()) {
@@ -704,20 +708,8 @@
         if (m_inputJar != null) {
             return m_inputJar.getManifest();
         } else {
-            if (m_manifest == null) {
-                File manFile = new File(m_dir, "META-INF/MANIFEST.MF");
-                if (manFile.exists()) {
-                    return new Manifest(new FileInputStream(manFile));
-                } else {
-                    throw new IOException("Cannot find the manifest file : " + manFile.getAbsolutePath());
-                }
-            } else {
-                if (m_manifest.exists()) {
-                    return  new Manifest(new FileInputStream(m_manifest));
-                } else {
-                    throw new IOException("Cannot find the manifest file : " + m_manifest.getAbsolutePath());
-                }
-            }
+            // -- PATCH - isandlaTech (T.C.) - Let the read process be overriden -- //
+            return new Manifest(getManifestInputStream());
         }
     }
 
@@ -1117,6 +1109,13 @@
      * @return : given manipulation metadata + manipulation metadata of the given element.
      */
     private StringBuffer buildManifestMetadata(Element element, StringBuffer actual) {
+
+        // -- BEGIN Patch - isandlaTech (T.C.) - 26/10/2010 -- //
+        if(isInjectedElement(element)) {
+            return actual;
+        }
+        // -- END Patch - isandlaTech (T.C.) - 26/10/2010 -- //
+
         StringBuffer result = new StringBuffer();
         if (element.getNameSpace() == null) {
             result.append(actual + element.getName() + " { ");
@@ -1127,6 +1126,7 @@
         Attribute[] atts = element.getAttributes();
         for (int i = 0; i < atts.length; i++) {
             Attribute current = (Attribute) atts[i];
+
             if (current.getNameSpace() == null) {
                 result.append("$" + current.getName() + "=\"" + current.getValue() + "\" ");
             } else {
@@ -1143,6 +1143,112 @@
         return result;
     }
 
+    // -- BEGIN Patch - isandlaTech (T.C.) - 26/10/2010 -- //
+    /**
+     * Tests if the given element is an iPOJO generated element from a prior treatment
+     * @return : true if the given element was prior injected by iPOJO
+     */
+    private boolean isInjectedElement(final Element element) {
+        Attribute[] atts = element.getAttributes();
+
+        if(m_manifestAttributeFilters == null) {
+            return false;
+        }
+
+        for(int i = 0; i < atts.length; i++) {
+
+            // First test : iPOJO injected elements filter
+            String value = atts[i].getValue();
+            if(value.startsWith(MethodCreator.PREFIX)
+                || value.contains("org.apache.felix.ipojo.InstanceManager")
+                || value.contains("_setInstanceManager")) {
+
+                    return true;
+            }
+
+            // Second test : personnalized filters
+            Iterator iterator = m_manifestAttributeFilters.iterator();
+            while(iterator.hasNext()) {
+                IManifestAttributeFilter filter = (IManifestAttributeFilter) iterator.next();
+
+                if(filter.isInFilter(atts[i])) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Adds a Manifest attribute filter to the list
+     *
+     * @param filter - The new Manifest attribute filter
+     */
+    public void addManifestAttributeFilters(final IManifestAttributeFilter filter) {
+        if(filter != null) {
+            m_manifestAttributeFilters.add(filter);
+        }
+    }
+
+    /**
+     * Retrieves an OutputStream to write in the Manifest.
+     *
+     * @return A valid output stream
+     */
+    protected void writeManifest(Manifest mf) throws IOException {
+        if (m_manifest == null) {
+            m_manifest = new File(m_dir, "META-INF/MANIFEST.MF");
+            if (! m_manifest.exists()) {
+                throw new IOException("Cannot find the manifest file : " + m_manifest.getAbsolutePath());
+            }
+        } else {
+            if (! m_manifest.exists()) {
+                throw new IOException("Cannot find the manifest file : " + m_manifest.getAbsolutePath());
+            }
+        }
+
+        mf.write(new FileOutputStream(m_manifest));
+    }
+
+    /**
+     * Retrieves an InputStream to read the Manifest.
+     *
+     * @return A valid input stream
+     */
+    protected InputStream getManifestInputStream() throws IOException {
+        if (m_manifest == null) {
+            File manFile = new File(m_dir, "META-INF/MANIFEST.MF");
+            if (manFile.exists()) {
+                return new FileInputStream(manFile);
+            } else {
+                throw new IOException("Cannot find the manifest file : " + manFile.getAbsolutePath());
+            }
+        } else {
+            if (m_manifest.exists()) {
+                return new FileInputStream(m_manifest);
+            } else {
+                throw new IOException("Cannot find the manifest file : " + m_manifest.getAbsolutePath());
+            }
+        }
+    }
+
+    /**
+     * Writes the .class raw data to the storage support
+     *
+     * @param classFile - Output .class file
+     * @param rawClass - Raw class representation
+     * @throws IOException - Something wrong occurred while writing the file
+     */
+    // -- Let it be overriden by a child class -- //
+    protected void setBytecode(final File classFile, final byte[] rawClass) throws IOException {
+        OutputStream os = new FileOutputStream(classFile);
+        os.write(rawClass);
+        os.close();
+    }
+
+    // -- END Patch - isandlaTech (T.C.) - 26/10/2010 -- //
+
     public List getWarnings() {
         return m_warnings;
     }
